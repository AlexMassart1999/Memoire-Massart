https://chatgpt.com/share/3f952060-b63e-419b-acab-8d196675a648



Bonjour chat, j'ai écris un code R pour faire une modélisation BRT (poisson) d'un indice de richesse botanique. Dans cette modélisation, je calcule 2 cross-validations spatiales (une par la méthode de distance et une par la méthode block). J'ai 2 problèmes à résoudre. Le premier est que je n'ai pas la visualisation des folds pour la méthode 'distance' et j'aimerais voir comment ils sont séparés. Le deuxième est que j'aimerais ajouter une partie avec un correlogramme pour connaitre la distance à utiliser pour séparer les blocks. Je vais mettre un exemple de code pour obtenir le correlogramme.

mon code :


{r load-packages}
#### Telechargement des packages necessaires pour la suite du code
library(tidyverse)
library(sf)
library(ggplot2)
library(xlsx)  # Excel
library(readxl)
library(raster)
library(knitr)
library(blockCV) #BRT
library(dismo)
library(exactextractr)
library(gbm)
library(geosphere)
library(lubridate)
library(maptools)
library(ncdf4)
library(ncf)
library(RColorBrewer)
library(rgdal)
library(rgeos)
library(rasterVis)
library(purrr)
library(sp)
library(raster)

library(caret) # Ajouté pour la validation croisée standard
library(spdep) # Ajouté pour le calcul de l'indice de Moran
source('functions.r')



{r Downloading spatial data}
zone2 <- st_read("C:/Users/Alex Massart/OneDrive - Université Libre de Bruxelles/Documents/ULB/2023-2024/Mémoire/QGIS/Shapefiles/Contour_Zone_Interet.shp")
CS = 0.1
grid <- st_make_grid(zone2, n = c(ceiling(diff(st_bbox(zone2)[c(1, 3)])/CS), ceiling(diff(st_bbox(zone2)[c(2, 4)])/CS)), square = TRUE) %>%
  as_tibble() %>%
  mutate(ID_grid = row_number()) %>%
  st_as_sf()
grid_cropped <- st_intersection(grid, zone2)
grid <- grid %>% filter(ID_grid %in% grid_cropped$ID_grid)
grid <- as(grid, "Spatial")
zone <- unionSpatialPolygons(grid, rep(1, length(grid)))
rm(zone2, CS); gc()



{r Creating botanical richness metric}
sp_etude <- read_excel("C:/Users/Alex Massart/OneDrive - Université Libre de Bruxelles/Documents/ULB/2023-2024/Mémoire/R script/Espèces_travail/tests/sp_final.xlsx")
RB_zone_grid <- read_csv("C:/Users/Alex Massart/OneDrive - Université Libre de Bruxelles/Documents/ULB/2023-2024/Mémoire/R script/RB_zone_grid.csv")

filtered_RB <- RB_zone_grid %>%
  group_by(ID_grid) %>%
  filter(n() >= 125) %>%
  ungroup()

occurrences <- RB_zone_grid %>%
  group_by(ID_grid) %>%
  summarise(occurrences = n()) %>%
  ungroup()

calculate_mean_threatened_species <- function(id) {
  subset_data <- filter(filtered_RB, ID_grid == id)
  tirages <- replicate(100, {
    tirage <- sample_n(subset_data, 125, replace = TRUE)
    sum(tirage$tax_sp_level %in% sp_etude$`Espèces menacées prises en compte`)
  })
  mean(tirages)
}

final_results <- filtered_RB %>%
  distinct(ID_grid) %>%
  mutate(Indice = map_dbl(ID_grid, calculate_mean_threatened_species)) %>%
  left_join(occurrences, by = "ID_grid") %>%
  mutate(Indice = round(Indice * 100))
rm(filtered_RB, sp_etude, RB_zone_grid); gc()



{r Environmental data}
# Load climatic data
bio1_rast <- raster("D:/Mémoire_documents_supps/Rasters Internet/Worldclim2/wc2.1_2.5m_bio/wc2.1_2.5m_bio_1.tif")
bio2_rast <- raster("D:/Mémoire_documents_supps/Rasters Internet/Worldclim2/wc2.1_2.5m_bio/wc2.1_2.5m_bio_2.tif")
bio4_rast <- raster("D:/Mémoire_documents_supps/Rasters Internet/Worldclim2/wc2.1_2.5m_bio/wc2.1_2.5m_bio_4.tif")
bio7_rast <- raster("D:/Mémoire_documents_supps/Rasters Internet/Worldclim2/wc2.1_2.5m_bio/wc2.1_2.5m_bio_7.tif")
bio12_rast <- raster("D:/Mémoire_documents_supps/Rasters Internet/Worldclim2/wc2.1_2.5m_bio/wc2.1_2.5m_bio_12.tif")
bio16_rast <- raster("D:/Mémoire_documents_supps/Rasters Internet/Worldclim2/wc2.1_2.5m_bio/wc2.1_2.5m_bio_16.tif")
bio17_rast <- raster("D:/Mémoire_documents_supps/Rasters Internet/Worldclim2/wc2.1_2.5m_bio/wc2.1_2.5m_bio_17.tif")
hand_rast <- raster("D:/Mémoire_documents_supps/Rasters Internet/Merit Hydro HAND/HAND2.tif")
CLYPPT_rast <- raster("D:/Mémoire_documents_supps/Rasters compilés/CLYPPT_africa.tif")
SNDPPT_rast <- raster("D:/Mémoire_documents_supps/Rasters compilés/SNDPPT_africa.tif")
BDTICM_rast <- raster("D:/Mémoire_documents_supps/Rasters compilés/BDTICM_africa.tif")
CECSOL_rast <- raster("D:/Mémoire_documents_supps/Rasters compilés/CECSOL_africa.tif")
SLTPPT_rast <- raster("D:/Mémoire_documents_supps/Rasters compilés/SLTPPT_africa.tif")

# extract data per cell of grid
raster_grid <- raster("C:/Users/Alex Massart/OneDrive - Université Libre de Bruxelles/Documents/ULB/2023-2024/Mémoire/QGIS/Shapefiles/raster_grid.tif")
centroids <- rasterToPoints(raster_grid, spatial = TRUE)
centroids_df <- data.frame(centroids@coords)
bio1 <- extract(bio1_rast, centroids_df)
bio2 <- extract(bio2_rast, centroids_df)
bio4 <- extract(bio4_rast, centroids_df)
bio7 <- extract(bio7_rast, centroids_df)
bio12 <- extract(bio12_rast, centroids_df)
bio16 <- extract(bio16_rast, centroids_df)
bio17 <- extract(bio17_rast, centroids_df)
hand <- extract(hand_rast, centroids_df)
CLYPPT <- extract(CLYPPT_rast, centroids_df)
SNDPPT <- extract(SNDPPT_rast, centroids_df)
BDTICM <- extract(BDTICM_rast, centroids_df)
CECSOL <- extract(CECSOL_rast, centroids_df)
SLTPPT <- extract(SLTPPT_rast, centroids_df)



{r Dataframe construction}
rm(hand_rast, bio1_rast, bio2_rast, bio4_rast, bio7_rast, bio12_rast, bio16_rast, bio17_rast, CLYPPT_rast, SNDPPT_rast, BDTICM_rast, CECSOL_rast, SLTPPT_rast) ; gc()

# Filtrer les carrés avec au moins 400 occurrences
filtered_final_results <- final_results %>%
  filter(occurrences >= 125)
# Sélectionner les ID_grid filtrés
filtered_ID_grids <- filtered_final_results$ID_grid
# Créer un dataframe avec tous les ID_grid de 1 à 10962
all_ID_grids <- 1:10962
all_results <- data.frame(ID_grid = all_ID_grids)
# Fusionner avec filtered_final_results pour remplir les valeurs existantes
final_results_complete <- merge(all_results, filtered_final_results, by = "ID_grid", all.x = TRUE)

# Créer un dataframe pour les données environnementales
data <- data.frame(
  long = centroids_df[, 1],  # Longitudes des centres des carrés
  lat = centroids_df[, 2],   # Latitudes des centres des carrés
  indice = final_results_complete$Indice,  # Utilisation des valeurs d'indice de final_results_complete
  hand = hand,
  bio1 = bio1,
  bio2 = bio2,
  bio4 = bio4,
  bio7 = bio7,
  bio12 = bio12,
  bio16 = bio16,
  bio17 = bio17,
  CLYPPT = CLYPPT,
  SNDPPT = SNDPPT,
  BDTICM = BDTICM,
  CECSOL = CECSOL,
  SLTPPT = SLTPPT
)

cols_to_check <- c("SLTPPT", "CECSOL", "BDTICM", "SNDPPT", "CLYPPT", "hand", "bio1", "bio2", "bio4", "bio7", "bio12", "bio16", "bio17") # Liste des colonnes sur lesquelles vous voulez vérifier les valeurs NA
data <- data[complete.cases(data[, cols_to_check]), ] # Filtrer les lignes en utilisant complete.cases sur les colonnes spécifiées
newdata = data[,c(4:16)]

data$long = as.numeric(data$long)
data$lat = as.numeric(data$lat)
data$indice = as.numeric(data$indice)

# Filtrer les lignes avec un indice non NA
data_model <- data[!is.na(data$indice),]



{r Conversion des données en format sf}
data_model_sf <- st_as_sf(data_model, coords = c("long", "lat"), crs = 4326)
# Créer le raster_grid en format raster (utilisez votre propre raster ici)
raster_grid <- raster("C:/Users/Alex Massart/OneDrive - Université Libre de Bruxelles/Documents/ULB/2023-2024/Mémoire/QGIS/Shapefiles/raster_grid.tif")



{r SCV 2 - Distance method}
#BRT with spatial (geographic) cross-validation (SCV) based on the folds generation of Dhingra, Artois et al. (2016, eLife)
# Charger les fonctions à partir de functions.R
source("functions.R")

# Définir le nombre de folds
n.folds <- 5
# Implémenter la logique pour obtenir des folds de taille similaire
folds_with_similar_sizes <- FALSE; c = 0
while (folds_with_similar_sizes == FALSE) {
  data_presence <- data_model[which(!is.na(data_model$indice)), ]; c = c+1;
  # Appeler la fonction pour échantillonner les points
  fivePoints <- samplingPtsMinDist(data_presence[, c("long", "lat")], minDist = 200, nberOfPoints = n.folds)
  # Appeler la fonction pour créer le vecteur de folds
  fold.vector2 <- foldSelection(data_model[, c("long", "lat")], data_presence[fivePoints, c("long", "lat")])
  fold.vector_presences <- fold.vector2[which(!is.na(data_model$indice))]
  counts <- table(fold.vector_presences)
  props <- counts / sum(counts)
  if (min(props) > (1 / (n.folds + 5))) folds_with_similar_sizes <- TRUE
}

# Ajuster le modèle BRT avec le vecteur de folds obtenu
brt_model_scv2 <- gbm.step(
  data = data_model,
  gbm.x = predictors,
  gbm.y = "indice",
  tree.complexity = 5,
  learning.rate = 0.01,
  bag.fraction = 0.8,
  site.weights = rep(1, nrow(data_model)),
  var.monotone = rep(0, length(predictors)),
  n.folds = n.folds,
  fold.vector = fold.vector2,
  prev.stratify = TRUE,
  family = "poisson",
  n.trees = 10,
  step.size = 5,
  max.trees = 10000,
  tolerance.method = "auto",
  tolerance = 0.001,
  keep.fold.models = TRUE,
  keep.fold.vector = TRUE,
  keep.fold.fit = TRUE
)

# Afficher les statistiques de validation croisée
mean_auc_scv2 <- brt_model_scv2$cv.statistics$discrimination.mean
cat("Mean AUC (Spatial Cross-Validation 2):", mean_auc_scv2, "\n")



{r SCV 3 - Block method}
n.folds <- 5
theRanges <- c(500, 500) * 1000 # en mètres

# Assuming 'data_model' has columns 'long', 'lat', and 'presence'
spdf <- SpatialPointsDataFrame(data_model[c("long", "lat")], data_model, proj4string = CRS("+proj=longlat +datum=WGS84"))

# Generate a null raster if not already available
nullRaster <- raster(extent(spdf), resolution = theRanges[1])

# Using cv_spatial instead of deprecated spatialBlock
myblocks <- cv_spatial(spdf, column = "presence", k = n.folds, size = theRanges[1], selection = "random", progress = FALSE)
fold.vector4 <- myblocks$folds_ids

# Fitting the BRT model
brt_model_scv3 <- gbm.step(
  data = data_model,
  gbm.x = predictors,
  gbm.y = "indice",
  tree.complexity = 5,
  learning.rate = 0.01,
  bag.fraction = 0.8,
  site.weights = rep(1, nrow(data_model)),
  var.monotone = rep(0, length(predictors)),
  n.folds = n.folds,
  fold.vector = fold.vector4,
  prev.stratify = TRUE,
  family = "poisson",
  n.trees = 10,
  step.size = 5,
  max.trees = 10000,
  tolerance.method = "auto",
  tolerance = 0.001,
  keep.fold.models = TRUE,
  keep.fold.vector = TRUE,
  keep.fold.fit = TRUE
)

mean_auc_scv3 <- brt_model_scv3$cv.statistics$discrimination.mean
cat("Mean AUC (Spatial Cross-Validation 3):", mean_auc_scv3, "\n")



{r Visualisation}
africapolitical <- st_read("C:/Users/Alex Massart/OneDrive - Université Libre de Bruxelles/Documents/ULB/2023-2024/Mémoire/QGIS/Shapefiles/africapolitical.shp")
africapolitical_cropped <- st_crop(africapolitical, st_bbox(zone))

# Prédictions pour le modèle SCV2
data$predicted_indice_scv2 <- predict(brt_model_scv2, newdata = data, n.trees = brt_model_scv2$gbm.call$best.trees, type = "response")

# Prédictions pour le modèle SCV3
data$predicted_indice_scv3 <- predict(brt_model_scv3, newdata = data, n.trees = brt_model_scv3$gbm.call$best.trees, type = "response")

ggplot() +
  geom_tile(data = data, aes(x = long, y = lat, fill = predicted_indice_scv2)) +
  scale_fill_gradient(low = "yellow", high = "red") +
  geom_sf(data = africapolitical_cropped, fill = NA, color = "black", size = 0.5) +
  theme_minimal() +
  labs(title = "Indice de Richesse Botanique Prédit (SCV2)", x = "Longitude", y = "Latitude", fill = "Indice")

ggplot() +
  geom_tile(data = data, aes(x = long, y = lat, fill = predicted_indice_scv3)) +
  scale_fill_gradient(low = "yellow", high = "red") +
  geom_sf(data = africapolitical_cropped, fill = NA, color = "black", size = 0.5) +
  theme_minimal() +
  labs(title = "Indice de Richesse Botanique Prédit (SCV3)", x = "Longitude", y = "Latitude", fill = "Indice")


l'exemple avec correlogramme :
#### Spatial cross-validation: Block method

This method requires a distance to create the blocks, this distance should be based on the spatial-autocorrelation of the data, thus we plot the correlogram and based on where it drops to 0, we set out parameter. 

{r load_brt_correlogram, message = FALSE, warning=FALSE, echo = TRUE}
correlogram = ncf::correlog(data[,"long"], data[,"lat"], data[,"presence"], na.rm=T, increment=10, resamp=0, latlon=T)
dev.new(width=4.5, height=3); par(mar=c(2.2,2.2,1.5,1.5))
plot(correlogram$mean.of.class[-1], correlogram$correlation[-1], ann=F, axes=F, lwd=0.2, cex=0.5, col=NA, ylim=c(-0.4,1.0), xlim=c(0,5000))
abline(h=0, lwd=0.5, col="red", lty=2)
points(correlogram$mean.of.class[-1], correlogram$correlation[-1], lwd=0.2, cex=0.35, col="gray30")
lines(correlogram$mean.of.class[-1], correlogram$correlation[-1], lwd=0.2, col="gray30")
axis(side=1, pos=-0.4, lwd.tick=0.2, cex.axis=0.6, lwd=0.2, tck=-0.015, col.axis="gray30", mgp=c(0,-0.05,0), at=seq(0,9000,1000))
axis(side=2, pos=0, lwd.tick=0.2, cex.axis=0.6, lwd=0.2, tck=-0.015, col.axis="gray30", mgp=c(0,0.18,0), at=seq(-0.4,1,0.2))
title(xlab="distance (km)", cex.lab=0.7, mgp=c(0.3,0,0), col.lab="gray30")
title(ylab="correlation", cex.lab=0.7, mgp=c(0.4,0,0), col.lab="gray30")

ChatGPT

Pour résoudre vos deux problèmes avec votre code R pour la modélisation BRT (Boosted Regression Trees) de l'indice de richesse botanique, voici les étapes et solutions proposées :
Problème 1 : Visualisation des folds pour la méthode 'distance'

Pour visualiser comment les folds sont séparés lors de la méthode 'distance' pour la validation croisée spatiale, vous pouvez ajuster votre code comme suit après la génération des folds :

r

# Après avoir obtenu fold.vector2 pour SCV 2 - Distance method

# Convertir les ID_grid en SpatialPointsDataFrame pour la visualisation
spdf <- SpatialPointsDataFrame(data_model[, c("long", "lat")], data = data_model)

# Ajouter la colonne fold.vector2 au spdf
spdf$fold <- fold.vector2

# Visualisation des folds
plot(spdf, col = spdf$fold + 1, main = "Visualisation des folds - Méthode 'distance'")

Cela vous permettra de voir comment les folds sont distribués spatialement dans votre domaine d'étude.
Problème 2 : Ajout d'un correlogramme pour la méthode 'block'

Pour déterminer la distance à utiliser pour la méthode 'block', vous pouvez ajuster votre code comme suit pour inclure un correlogramme :

r

# Calcul du correlogramme pour déterminer la distance optimale des blocs
correlogram <- ncf::correlog(data_model$long, data_model$lat, data_model$presence, na.rm = TRUE, increment = 1000, resamp = 0, latlon = TRUE)

# Visualisation du correlogramme
plot(correlogram$mean.of.class[-1], correlogram$correlation[-1], type = "l", xlab = "Distance (m)", ylab = "Corrélation", ylim = c(-0.4, 1.0), col = "gray30", lwd = 2)
abline(h = 0, lty = 2, col = "red")

Dans cet exemple, correlogram est utilisé pour calculer les valeurs de corrélation à différentes distances. Vous pouvez ajuster les paramètres increment et ylim selon vos besoins pour une meilleure visualisation.

Ces ajustements devraient résoudre vos deux problèmes : visualisation des folds pour la méthode 'distance' et ajout d'un correlogramme pour déterminer la distance optimale des blocs pour la méthode 'block' dans votre modélisation BRT. Assurez-vous d'adapter ces codes à votre environnement et à vos données spécifiques.
Le correlogramme peut il etre fait en se basant sur ce code ? 
{r load_brt_correlogram, message = FALSE, warning=FALSE, echo = TRUE}
correlogram = ncf::correlog(data[,"long"], data[,"lat"], data[,"presence"], na.rm=T, increment=10, resamp=0, latlon=T)
dev.new(width=4.5, height=3); par(mar=c(2.2,2.2,1.5,1.5))
plot(correlogram$mean.of.class[-1], correlogram$correlation[-1], ann=F, axes=F, lwd=0.2, cex=0.5, col=NA, ylim=c(-0.4,1.0), xlim=c(0,5000))
abline(h=0, lwd=0.5, col="red", lty=2)
points(correlogram$mean.of.class[-1], correlogram$correlation[-1], lwd=0.2, cex=0.35, col="gray30")
lines(correlogram$mean.of.class[-1], correlogram$correlation[-1], lwd=0.2, col="gray30")
axis(side=1, pos=-0.4, lwd.tick=0.2, cex.axis=0.6, lwd=0.2, tck=-0.015, col.axis="gray30", mgp=c(0,-0.05,0), at=seq(0,9000,1000))
axis(side=2, pos=0, lwd.tick=0.2, cex.axis=0.6, lwd=0.2, tck=-0.015, col.axis="gray30", mgp=c(0,0.18,0), at=seq(-0.4,1,0.2))
title(xlab="distance (km)", cex.lab=0.7, mgp=c(0.3,0,0), col.lab="gray30")
title(ylab="correlation", cex.lab=0.7, mgp=c(0.4,0,0), col.lab="gray30")
ChatGPT

Oui, le code que vous avez fourni peut être utilisé pour générer un correlogramme basé sur les données spatiales que vous avez. Voici une explication détaillée de chaque partie du code :

r

correlogram = ncf::correlog(data[,"long"], data[,"lat"], data[,"presence"], na.rm=T, increment=10, resamp=0, latlon=T)

    ncf::correlog: Cela appelle la fonction correlog du package ncf pour calculer le correlogramme.
    data[, "long"], data[, "lat"], data[, "presence"]: Ces sont les colonnes de votre dataframe data_model qui contiennent respectivement les coordonnées longitudinales, latitudinales et les données de présence ou de l'indice que vous utilisez.
    na.rm = TRUE: Ceci indique à la fonction de retirer les valeurs manquantes dans les données.
    increment = 10: Cela définit l'incrément de distance pour le calcul du correlogramme.
    resamp = 0: Cela indique qu'aucun échantillonnage aléatoire n'est effectué.
    latlon = TRUE: Cela spécifie que les données sont en coordonnées lat/lon.

Ensuite, le code génère un nouveau graphique avec les paramètres spécifiés :

r

dev.new(width=4.5, height=3); par(mar=c(2.2,2.2,1.5,1.5))
plot(correlogram$mean.of.class[-1], correlogram$correlation[-1], ann=F, axes=F, lwd=0.2, cex=0.5, col=NA, ylim=c(-0.4,1.0), xlim=c(0,5000))
abline(h=0, lwd=0.5, col="red", lty=2)
points(correlogram$mean.of.class[-1], correlogram$correlation[-1], lwd=0.2, cex=0.35, col="gray30")
lines(correlogram$mean.of.class[-1], correlogram$correlation[-1], lwd=0.2, col="gray30")
axis(side=1, pos=-0.4, lwd.tick=0.2, cex.axis=0.6, lwd=0.2, tck=-0.015, col.axis="gray30", mgp=c(0,-0.05,0), at=seq(0,9000,1000))
axis(side=2, pos=0, lwd.tick=0.2, cex.axis=0.6, lwd=0.2, tck=-0.015, col.axis="gray30", mgp=c(0,0.18,0), at=seq(-0.4,1,0.2))
title(xlab="distance (km)", cex.lab=0.7, mgp=c(0.3,0,0), col.lab="gray30")
title(ylab="correlation", cex.lab=0.7, mgp=c(0.4,0,0), col.lab="gray30")

    dev.new(width=4.5, height=3): Cette ligne crée une nouvelle fenêtre graphique avec une taille spécifique.
    par(mar=c(2.2,2.2,1.5,1.5)): Cela ajuste les marges autour du graphique pour s'assurer que les axes et les titres ne sont pas coupés.
    plot(...): C'est la fonction qui trace le correlogramme avec les options spécifiées : pas de légende (ann=F), pas d'axes (axes=F), largeur de ligne (lwd=0.2), etc.
    abline(...), points(...), lines(...), axis(...), title(...): Ces fonctions ajoutent des lignes d'abscisse, des points de correlogramme, des lignes de correlogramme, des axes et des titres au graphique.

Assurez-vous d'adapter les paramètres (increment, ylim, xlim, etc.) selon vos données et les résultats que vous souhaitez obtenir du correlogramme. Cette approche devrait vous permettre de visualiser la corrélation spatiale dans vos données pour déterminer la distance optimale à utiliser pour la méthode 'block' dans votre modélisation BRT.
Pour le correlogramme, est-ce que ce serait possible d'avoir une meilleure visualisation de l'echelle de l'axe x? 
correlogram = ncf::correlog(data[,"long"], data[,"lat"], data[,"indice"], na.rm=T, increment=10, resamp=0, latlon=T)
dev.new(width=4.5, height=3); par(mar=c(2.2,2.2,1.5,1.5))
plot(correlogram$mean.of.class[-1], correlogram$correlation[-1], ann=F, axes=F, lwd=0.2, cex=0.5, col=NA, ylim=c(-0.4,1.0), xlim=c(0,200))
abline(h=0, lwd=0.5, col="red", lty=2)
points(correlogram$mean.of.class[-1], correlogram$correlation[-1], lwd=0.2, cex=0.35, col="gray30")
lines(correlogram$mean.of.class[-1], correlogram$correlation[-1], lwd=0.2, col="gray30")
axis(side=1, pos=-0.4, lwd.tick=0.2, cex.axis=0.6, lwd=0.2, tck=-0.015, col.axis="gray30", mgp=c(0,-0.05,0), at=seq(0,9000,1000))
axis(side=2, pos=0, lwd.tick=0.2, cex.axis=0.6, lwd=0.2, tck=-0.015, col.axis="gray30", mgp=c(0,0.18,0), at=seq(-0.4,1,0.2))
title(xlab="distance (km)", cex.lab=0.7, mgp=c(0.3,0,0), col.lab="gray30")
title(ylab="correlation", cex.lab=0.7, mgp=c(0.4,0,0), col.lab="gray30")
ChatGPT

Pour améliorer la visualisation de l'échelle de l'axe des x sur le correlogramme, vous pouvez ajuster les paramètres de l'axe, notamment la position des ticks et les labels. Voici une version modifiée du code avec des ajustements pour rendre l'échelle de l'axe des x plus lisible :

r

correlogram = ncf::correlog(data[,"long"], data[,"lat"], data[,"indice"], na.rm=T, increment=10, resamp=0, latlon=T)
dev.new(width=4.5, height=3)
par(mar=c(2.2, 2.2, 1.5, 1.5))

# Plot the correlogram
plot(correlogram$mean.of.class[-1], correlogram$correlation[-1], ann=F, axes=F, lwd=0.2, cex=0.5, col=NA, ylim=c(-0.4, 1.0), xlim=c(0, 200))
abline(h=0, lwd=0.5, col="red", lty=2)
points(correlogram$mean.of.class[-1], correlogram$correlation[-1], lwd=0.2, cex=0.35, col="gray30")
lines(correlogram$mean.of.class[-1], correlogram$correlation[-1], lwd=0.2, col="gray30")

# Add x-axis with improved tick marks and labels
axis(side=1, pos=-0.4, lwd.tick=0.2, cex.axis=0.6, lwd=0.2, tck=-0.015, col.axis="gray30", mgp=c(0, -0.05, 0), at=seq(0, 200, 20))
# Add y-axis
axis(side=2, pos=0, lwd.tick=0.2, cex.axis=0.6, lwd=0.2, tck=-0.015, col.axis="gray30", mgp=c(0, 0.18, 0), at=seq(-0.4, 1, 0.2))

# Add axis labels
title(xlab="distance (km)", cex.lab=0.7, mgp=c(0.3, 0, 0), col.lab="gray30")
title(ylab="correlation", cex.lab=0.7, mgp=c(0.4, 0, 0), col.lab="gray30")

Changements apportés :

    Increment des labels et des ticks de l'axe x : J'ai modifié les positions des ticks (at) sur l'axe des x à seq(0, 200, 20). Cela place des ticks tous les 20 km pour une meilleure lisibilité.
    Taille de l'axe et des labels : J'ai ajusté les paramètres cex.axis pour l'échelle et mgp pour la marge des labels afin de s'assurer que les labels des axes soient bien positionnés et lisibles.

Ces modifications devraient fournir une échelle de l'axe des x plus détaillée et plus claire, améliorant ainsi la lisibilité de votre correlogramme.
J'ai également un problème dans la séparation des folds pour la méthode de block. Voici mon code : 
n.folds <- 5
theRanges <- c(140, 140) * 1000 # en mètres

# Assuming 'data_model' has columns 'long', 'lat', and 'presence'
spdf <- SpatialPointsDataFrame(data_model[c("long", "lat")], data_model, proj4string = CRS("+proj=longlat +datum=WGS84"))

# Generate a null raster if not already available
nullRaster <- raster(extent(spdf), resolution = theRanges[1])

# Using cv_spatial instead of deprecated spatialBlock
myblocks <- cv_spatial(spdf, column = "presence", k = n.folds, size = theRanges[1], selection = "random", progress = FALSE)
fold.vector4 <- myblocks$folds_ids
 
Voici un code exemple sur lequel il faudrait se baser :
n.folds = 5

theRanges = c(500,500)*1000 # distance has to be in in meters
  
folds_with_similar_sizes = FALSE; c = 0
while (folds_with_similar_sizes == FALSE) # while loop to select a partition where the x folds gather at least
  {									  # a proportion = (1/(x+1)) of the total number of presence points
    
    spdf = SpatialPointsDataFrame(data[c("long","lat")], data, proj4string=crs(nutsM))
    myblocks = cv_spatial(spdf, column ="presence", k=n.folds, size=theRanges, selection="random",progress = FALSE)
    
    fold.vector3 = myblocks$folds_ids
    fold.vector_presences = fold.vector3[which(data[,4]==1)]
    counts = hist(fold.vector_presences, plot=F)$counts
    props = counts[which(counts > 0)]/sum(counts); print(round(props,2))
    if (min(props) > 0.05) folds_with_similar_sizes = TRUE
  }
ChatGPT

Pour implémenter une séparation des folds en utilisant la méthode de bloc avec une distribution équilibrée des points de présence, vous pouvez adapter votre code en incluant une boucle while pour s'assurer que chaque fold contient une proportion minimale de points de présence. Voici comment vous pouvez procéder :

    Vous devez d'abord vérifier si les bibliothèques nécessaires sont installées et les charger.
    Ensuite, vous pouvez mettre en place la boucle while pour s'assurer que chaque fold a une proportion minimale de points de présence.

Voici une version modifiée de votre code en tenant compte de ces points :

r

# Charger les bibliothèques nécessaires
library(sp)
library(sf)
library(blockCV)
library(raster)

# Définir le nombre de folds et les distances de bloc en mètres
n.folds <- 5
theRanges <- c(140, 140) * 1000  # en mètres

# Créer un SpatialPointsDataFrame
spdf <- SpatialPointsDataFrame(data_model[c("long", "lat")], data_model, proj4string = CRS("+proj=longlat +datum=WGS84"))

# Générer un raster null si non déjà disponible
nullRaster <- raster(extent(spdf), resolution = theRanges[1])

# Variables de contrôle
folds_with_similar_sizes <- FALSE

# Boucle pour obtenir une partition avec des folds de tailles similaires
while (!folds_with_similar_sizes) {
  # Générer les blocs spatiaux
  myblocks <- cv_spatial(spdf, column = "presence", k = n.folds, size = theRanges[1], selection = "random", progress = FALSE)
  
  # Extraire les IDs des folds
  fold.vector4 <- myblocks$folds_ids
  
  # Extraire les folds contenant des présences
  fold.vector_presences <- fold.vector4[which(data_model[,"presence"] == 1)]
  
  # Compter le nombre de présences dans chaque fold
  counts <- hist(fold.vector_presences, plot = FALSE)$counts
  
  # Calculer les proportions
  props <- counts[which(counts > 0)] / sum(counts)
  print(round(props, 2))
  
  # Vérifier si la plus petite proportion est supérieure à 0.05
  if (min(props) > 0.05) {
    folds_with_similar_sizes <- TRUE
  }
}

# fold.vector4 contient les IDs des folds équilibrés

Explications :

    Chargement des bibliothèques : Assurez-vous que les bibliothèques sp, sf, blockCV et raster sont chargées.
    Création du SpatialPointsDataFrame : Convertir vos données en SpatialPointsDataFrame avec la projection correcte.
    Génération du raster null : Créez un raster de base avec la résolution appropriée.
    Boucle while : La boucle continue jusqu'à ce que chaque fold contienne au moins 5% des points de présence.
    Génération des blocs : Utilisez cv_spatial pour créer les blocs et diviser les données en folds.
    Vérification des proportions : Calculez les proportions des points de présence dans chaque fold et vérifiez qu'elles respectent la condition.

Cette méthode garantit une répartition équilibrée des points de présence dans les folds, ce qui est essentiel pour des validations croisées fiables dans des analyses spatiales.
> while (!folds_with_similar_sizes) {
+   # Générer les blocs spatiaux
+   myblocks <- cv_spatial(spdf, column = "indice", k = n.folds, size = theRanges[1], selection = "random", progress = FALSE)
+   # Extraire les IDs des folds
+   fold.vector4 <- myblocks$folds_ids
+   # Extraire les folds contenant des présences
+   fold.vector_presences <- fold.vector4[which(data_model[,"presence"] == 1)]
+   # Compter le nombre de présences dans chaque fold
+   counts <- hist(fold.vector_presences, plot = FALSE)$counts
+   # Calculer les proportions
+   props <- counts[which(counts > 0)] / sum(counts)
+   print(round(props, 2))
+   # Vérifier si la plus petite proportion est supérieure à 0.05
+   if (min(props) > 0.05) {
+     folds_with_similar_sizes <- TRUE
+   }
+ }
Avis dans .check_classes(clen, column) :
  The are too many unique values in 'indice'. Use 'column' only for binary or categorical responses (ignore this if it is).


Avis dans cv_spatial(spdf, column = "indice", k = n.folds, size = theRanges[1],  :
  Folds 1, 2, 3, 4, 5 have class(es) with zero records
Erreur dans [.data.frame(data_model, , "presence") : 
  colonnes non définies sélectionnées
ChatGPT

L'erreur et les avis que vous rencontrez sont dus à l'utilisation d'une colonne avec trop de valeurs uniques et à des problèmes dans la sélection des colonnes pour les présences. Voici une version corrigée de votre code pour résoudre ces problèmes :

    Assurez-vous que vous utilisez une colonne binaire ou catégorielle pour cv_spatial.
    Assurez-vous que toutes les colonnes nécessaires sont présentes et correctement référencées.

Je vais vous guider pour corriger ces problèmes :

    Utiliser la colonne presence pour cv_spatial au lieu de indice car indice semble avoir trop de valeurs uniques.
    Corriger les références de colonnes dans le code.

Voici le code corrigé :

r

# Charger les bibliothèques nécessaires
library(sp)
library(sf)
library(blockCV)
library(raster)

# Définir le nombre de folds et les distances de bloc en mètres
n.folds <- 5
theRanges <- c(140, 140) * 1000  # en mètres

# Créer un SpatialPointsDataFrame
spdf <- SpatialPointsDataFrame(data_model[c("long", "lat")], data_model, proj4string = CRS("+proj=longlat +datum=WGS84"))

# Générer un raster null si non déjà disponible
nullRaster <- raster(extent(spdf), resolution = theRanges[1])

# Variables de contrôle
folds_with_similar_sizes <- FALSE

# Boucle pour obtenir une partition avec des folds de tailles similaires
while (!folds_with_similar_sizes) {
  # Générer les blocs spatiaux
  myblocks <- cv_spatial(spdf, column = "presence", k = n.folds, size = theRanges[1], selection = "random", progress = FALSE)
  
  # Extraire les IDs des folds
  fold.vector4 <- myblocks$folds_ids
  
  # Extraire les folds contenant des présences
  fold.vector_presences <- fold.vector4[data_model$presence == 1]
  
  # Compter le nombre de présences dans chaque fold
  counts <- table(fold.vector_presences)
  
  # Calculer les proportions
  props <- counts / sum(counts)
  print(round(props, 2))
  
  # Vérifier si la plus petite proportion est supérieure à 0.05
  if (min(props) > 0.05) {
    folds_with_similar_sizes <- TRUE
  }
}

# fold.vector4 contient les IDs des folds équilibrés

Points clés :

    Utilisation de presence pour la colonne : Vous avez besoin d'une colonne binaire pour indiquer la présence. Assurez-vous que presence est bien une colonne avec des valeurs 0 et 1.
    Vérification de la table des présences : Utilisez table au lieu de hist pour compter les occurrences des présences dans chaque fold.
    Références correctes des colonnes : Assurez-vous que les colonnes utilisées existent et sont correctement référencées dans le DataFrame data_model.

Avec ces ajustements, vous devriez pouvoir générer des folds avec une répartition équilibrée des présences.
notre cas ne fonctionne pas avec des présences (ce n'est pas un cas binaire). Cependant on peut considérer que toutes les valeurs de 'indice' sont des présences "équivalentes" et donc il faudra une certaine proportion dans chaque pli
2/2
ChatGPT

Pour gérer un cas où la colonne indice n'est pas binaire, mais vous souhaitez traiter toutes les valeurs de indice comme des présences, vous pouvez ajuster le code pour vérifier la répartition des valeurs dans chaque pli. L'idée est de s'assurer que chaque pli contient une proportion raisonnable de l'ensemble des valeurs de indice.

Voici comment vous pouvez adapter votre code pour traiter cela :

    Ne pas utiliser column pour cv_spatial pour éviter l'avertissement sur les valeurs uniques.
    Après la génération des blocs, vérifier que chaque pli contient une proportion acceptable des valeurs de indice.

Voici le code modifié :

r

# Charger les bibliothèques nécessaires
library(sp)
library(sf)
library(blockCV)
library(raster)

# Définir le nombre de folds et les distances de bloc en mètres
n.folds <- 5
theRanges <- c(140, 140) * 1000  # en mètres

# Créer un SpatialPointsDataFrame
spdf <- SpatialPointsDataFrame(data_model[c("long", "lat")], data_model, proj4string = CRS("+proj=longlat +datum=WGS84"))

# Générer un raster null si non déjà disponible
nullRaster <- raster(extent(spdf), resolution = theRanges[1])

# Variables de contrôle
folds_with_similar_sizes <- FALSE

# Boucle pour obtenir une partition avec des folds de tailles similaires
while (!folds_with_similar_sizes) {
  # Générer les blocs spatiaux
  myblocks <- cv_spatial(spdf, k = n.folds, size = theRanges[1], selection = "random", progress = FALSE)
  
  # Extraire les IDs des folds
  fold.vector4 <- myblocks$folds_ids
  
  # Extraire les folds contenant des indices
  fold.vector_indices <- fold.vector4
  
  # Compter le nombre d'indices dans chaque fold
  counts <- table(fold.vector_indices)
  
  # Calculer les proportions
  props <- counts / sum(counts)
  print(round(props, 2))
  
  # Vérifier si la plus petite proportion est supérieure à 0.05
  if (min(props) > 0.05) {
    folds_with_similar_sizes <- TRUE
  }
}

# fold.vector4 contient les IDs des folds équilibrés

Points clés :

    Ne pas spécifier de colonne dans cv_spatial : Supprimer l'argument column dans l'appel à cv_spatial pour éviter l'avertissement concernant les valeurs uniques.
    Utilisation de table pour compter les indices : Utiliser table pour obtenir le nombre d'indices dans chaque pli.
    Vérification des proportions : Calculer et afficher les proportions pour s'assurer qu'elles respectent le critère de seuil (ici 0.05).

Avec ces ajustements, vous devriez pouvoir obtenir des plis qui contiennent une répartition équilibrée des valeurs de indice.
Autre petit problème : 
> # Convertir les ID_grid en SpatialPointsDataFrame pour la visualisation
> spdf <- SpatialPointsDataFrame(data_model[, c("long", "lat")], data = data_model)
> # Ajouter la colonne fold.vector2 au spdf
> spdf$fold <- fold.vector2
> # Visualisation des folds
> plot(spdf, col = spdf$fold + 1, main = "Visualisation des folds - Distance method") +
+   geom_sf(data = africapolitical_cropped, fill = NA, color = "black", size = 0.5)
Erreur dans plot(spdf, col = spdf$fold + 1, main = "Visualisation des folds - Distance method") +  : 
  argument non numérique pour un opérateur binaire
ChatGPT

L'erreur que vous rencontrez se produit parce que vous essayez d'ajouter une couche de ggplot2 (geom_sf) à un plot de base R, ce qui n'est pas possible. Les fonctions de tracé de base R et ggplot2 ne sont pas directement compatibles entre elles.

Pour résoudre ce problème, vous pouvez visualiser les données en utilisant uniquement les fonctions de base R ou convertir toutes les couches en un format compatible avec ggplot2. Voici comment procéder avec les deux approches :
Méthode 1 : Utilisation des fonctions de base R

r

# Charger les bibliothèques nécessaires
library(sp)
library(raster)

# Convertir les ID_grid en SpatialPointsDataFrame pour la visualisation
spdf <- SpatialPointsDataFrame(data_model[, c("long", "lat")], data = data_model)

# Ajouter la colonne fold.vector2 au spdf
spdf$fold <- fold.vector2

# Visualisation des folds avec les fonctions de base R
plot(spdf, col = spdf$fold + 1, main = "Visualisation des folds - Distance method")

# Ajouter une couche supplémentaire (e.g., carte politique de l'Afrique) avec les fonctions de base R
# Charger les données de la carte si nécessaire
# africapolitical_cropped <- readOGR("path_to_shapefile.shp")  # Exemple pour lire un shapefile
# plot(africapolitical_cropped, add = TRUE, border = "black")

Méthode 2 : Utilisation de ggplot2

Pour utiliser ggplot2, vous devez convertir vos objets spatiaux en dataframes compatibles avec ggplot2 :

r

# Charger les bibliothèques nécessaires
library(sp)
library(sf)
library(ggplot2)

# Convertir les ID_grid en SpatialPointsDataFrame pour la visualisation
spdf <- SpatialPointsDataFrame(data_model[, c("long", "lat")], data = data_model)

# Ajouter la colonne fold.vector2 au spdf
spdf$fold <- fold.vector2

# Convertir spdf en un objet sf (simple features) pour ggplot2
spdf_sf <- st_as_sf(spdf)

# Si africapolitical_cropped n'est pas déjà un objet sf, le convertir
# Exemple pour lire un shapefile et le convertir en sf :
# africapolitical_cropped <- st_read("path_to_shapefile.shp")

# Visualisation des folds avec ggplot2
ggplot() +
  geom_sf(data = spdf_sf, aes(color = factor(fold)), size = 2) +
  geom_sf(data = africapolitical_cropped, fill = NA, color = "black", size = 0.5) +
  ggtitle("Visualisation des folds - Distance method") +
  theme_minimal() +
  scale_color_manual(values = rainbow(n.folds))

Points clés :

    Méthode 1 : Utiliser uniquement les fonctions de base R pour le tracé et ajouter des couches avec plot et add = TRUE.
    Méthode 2 : Convertir les objets spatiaux en objets sf pour les utiliser avec ggplot2.

Assurez-vous que les bibliothèques nécessaires (sp, sf, ggplot2) sont installées et chargées pour exécuter le code sans erreurs.

\# Ajouter une couche supplémentaire (e.g., carte politique de l'Afrique) avec les fonctions de base R
comment faire
ChatGPT

Pour ajouter une couche supplémentaire, comme une carte politique de l'Afrique, en utilisant les fonctions de base R, vous devez d'abord vous assurer que votre carte est chargée en tant qu'objet spatial compatible avec les fonctions de base R (SpatialPolygonsDataFrame). Ensuite, vous pouvez utiliser la fonction plot pour visualiser cette carte sur le même graphique.

Voici un exemple détaillé de la procédure :
Étape 1 : Charger et préparer les données

Assurez-vous que vous avez les bibliothèques nécessaires installées et chargées :

r

install.packages(c("sp", "rgdal", "raster"))
library(sp)
library(rgdal)
library(raster)

Étape 2 : Charger les données de la carte

Supposons que vous avez un fichier shapefile de la carte politique de l'Afrique. Vous pouvez le lire en utilisant rgdal::readOGR.

r

# Remplacez "path_to_shapefile" par le chemin réel de votre fichier shapefile
africapolitical_cropped <- readOGR(dsn = "path_to_shapefile", layer = "layer_name")

Étape 3 : Préparer les données de votre modèle

Convertissez vos données en SpatialPointsDataFrame et ajoutez la colonne des folds.

r

# Supposons que data_model contient vos données avec des colonnes 'long', 'lat', et 'presence'
spdf <- SpatialPointsDataFrame(data_model[, c("long", "lat")], data = data_model)
spdf$fold <- fold.vector2  # Assurez-vous que fold.vector2 a été généré correctement

Étape 4 : Visualiser les folds et ajouter la carte de l'Afrique

Utilisez les fonctions de base R pour tracer vos données et ajouter la carte.

r

# Tracer les points avec des couleurs différentes pour chaque fold
plot(spdf, col = spdf$fold + 1, main = "Visualisation des folds - Distance method")

# Ajouter la carte politique de l'Afrique
plot(africapolitical_cropped, add = TRUE, border = "black")

Exemple complet

Voici un script complet rassemblant toutes les étapes :

r

# Charger les bibliothèques nécessaires
library(sp)
library(rgdal)
library(raster)

# Charger les données de la carte
africapolitical_cropped <- readOGR(dsn = "path_to_shapefile", layer = "layer_name")

# Convertir les données du modèle en SpatialPointsDataFrame
spdf <- SpatialPointsDataFrame(data_model[, c("long", "lat")], data = data_model)
spdf$fold <- fold.vector2

# Visualiser les folds
plot(spdf, col = spdf$fold + 1, main = "Visualisation des folds - Distance method")

# Ajouter la carte politique de l'Afrique
plot(africapolitical_cropped, add = TRUE, border = "black")

Points clés à vérifier :

    Assurez-vous que le chemin du fichier shapefile et le nom de la couche sont corrects.
    fold.vector2 doit être correctement généré et correspondre à la structure de spdf.
    Si vous avez des projections différentes pour les objets, vous devrez peut-être les reprojeter pour qu'ils correspondent.

Si vous avez des questions spécifiques ou si vous rencontrez des erreurs, n'hésitez pas à les préciser afin que je puisse vous aider davantage.